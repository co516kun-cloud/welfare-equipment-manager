import { create } from 'zustand'
import type { ProductCategory, Product, ProductItem, Order, PreparationTask, User } from '../types'
import { supabaseDb } from '../lib/supabase-database'
import { supabase } from '../lib/supabase'
import { calculateInventorySummary, getAvailableStock, calculateReservations } from '../lib/inventory-utils'
import type { InventorySummary, ReservationInfo } from '../lib/inventory-utils'

interface InventoryState {
  // Data
  categories: ProductCategory[]
  products: Product[]
  items: ProductItem[]
  orders: Order[]
  preparationTasks: PreparationTask[]
  users: User[]
  
  // Cached items by category/product
  itemsCache: {
    categories: Record<string, ProductItem[]>
    products: Record<string, ProductItem[]>
  }
  
  // UI State
  selectedCategory: string | null
  selectedProduct: string | null
  viewMode: 'category' | 'product' | 'item'
  
  // Realtime state
  isRealtimeEnabled: boolean
  lastSyncTime: string | null
  
  // Initialization state
  isDataInitialized: boolean
  
  // Full sync state (for daily refresh)
  lastFullSyncTime: string | null
  
  // Actions
  loadData: () => Promise<void>
  loadAllDataOnStartup: () => Promise<void>
  loadItemsForCategory: (categoryId: string) => Promise<void>
  loadItemsForProduct: (productId: string) => Promise<void>
  clearItemsCache: () => void
  setViewMode: (mode: 'category' | 'product' | 'item') => void
  setSelectedCategory: (categoryId: string | null) => void
  setSelectedProduct: (productId: string | null) => void
  updateItemStatus: (itemId: string, status: ProductItem['status']) => Promise<void>
  createOrder: (order: Omit<Order, 'id'>) => Promise<void>
  updateOrderStatus: (orderId: string, status: Order['status']) => Promise<void>
  createPreparationTask: (task: Omit<PreparationTask, 'id'>) => Promise<void>
  updatePreparationTaskStatus: (taskId: string, status: PreparationTask['status']) => Promise<void>
  addProduct: (product: Omit<Product, 'id'>) => Promise<void>
  addProductItem: (item: Omit<ProductItem, 'id'>) => Promise<void>
  addCategory: (category: Omit<ProductCategory, 'id'>) => Promise<void>
  getInventoryStats: () => any
  
  // Inventory calculation methods
  getInventorySummary: () => InventorySummary[]
  getProductAvailableStock: (productId: string) => number
  getReservations: () => Map<string, ReservationInfo>
  
  // Realtime actions
  enableRealtime: () => void
  disableRealtime: () => void
  forceSync: () => Promise<void>
  
  // Daily sync actions
  checkAndPerformDailySync: () => Promise<void>
  
  // UI reset action
  resetUIState: () => void
}

// „É™„Ç¢„É´„Çø„Ç§„É†Êé•Á∂ö„ÅÆÁÆ°ÁêÜ
let realtimeSubscriptions: any[] = []

export const useInventoryStore = create<InventoryState>((set, get) => ({
  // Initial data
  categories: [],
  products: [],
  items: [],
  orders: [],
  preparationTasks: [],
  users: [],
  
  // Initial cache
  itemsCache: {
    categories: {},
    products: {}
  },
  
  // Initial UI state
  selectedCategory: null,
  selectedProduct: null,
  viewMode: 'category',
  
  // Initial realtime state
  isRealtimeEnabled: false,
  lastSyncTime: null,
  
  // Initial initialization state
  isDataInitialized: false,
  
  // Initial full sync state
  lastFullSyncTime: null,
  
  // Actions
  loadData: async () => {
    console.log('Loading basic data from Supabase...')
    try {
      // ÂïÜÂìÅÂÄã‰Ωì‰ª•Â§ñ„ÅÆÂü∫Êú¨„Éá„Éº„Çø„ÅÆ„ÅøË™≠„ÅøËæº„Åø
      const [categories, products, users, orders] = await Promise.all([
        supabaseDb.getCategories(),
        supabaseDb.getProducts(),
        supabaseDb.getUsers(),
        supabaseDb.getOrders()
      ])
      
      // preparation_tasks„ÅØÂÄãÂà•„Å´„É≠„Éº„ÉâÔºà„ÉÜ„Éº„Éñ„É´„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„Åü„ÇÅÔºâ
      let preparationTasks: PreparationTask[] = []
      try {
        preparationTasks = await supabaseDb.getPreparationTasks()
      } catch (error) {
        console.warn('Could not load preparation tasks:', error)
      }
      
      // ÁèæÂú®„ÅÆitems„ÇíÂèñÂæóÔºàÊó¢„Å´Ë™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ‰øùÊåÅÔºâ
      const currentState = get()
      const currentItems = currentState.items
      
      console.log('Loaded basic data from Supabase:', {
        categories: categories.length,
        products: products.length,
        users: users.length,
        orders: orders.length,
        preparationTasks: preparationTasks.length,
        itemsKept: currentItems.length // ‰øùÊåÅ„Åï„Çå„ÅüitemsÊï∞„Çí„É≠„Ç∞Âá∫Âäõ
      })
      
      set({
        categories,
        products,
        items: currentItems, // Êó¢Â≠ò„ÅÆitems„Çí‰øùÊåÅÔºàÁ©∫ÈÖçÂàó„Å´„Åó„Å™„ÅÑÔºâ
        orders,
        preparationTasks,
        users
      })
    } catch (error) {
      console.error('Error loading data from Supabase:', error)
    }
  },

  loadAllDataOnStartup: async () => {
    console.log('üöÄ Loading ALL data on startup using category-wise approach...')
    try {
      // „Ç´„ÉÜ„Ç¥„É™„ÉºÂà•Ë™≠„ÅøËæº„Åø„ÅßÂÖ®„Éá„Éº„Çø„ÇíÂèñÂæó
      const { categories, products, items, users, orders } = await supabaseDb.loadAllDataByCategory()
      
      // preparation_tasks„ÅØÂÄãÂà•„Å´„É≠„Éº„ÉâÔºà„ÉÜ„Éº„Éñ„É´„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„Åü„ÇÅÔºâ
      let preparationTasks: PreparationTask[] = []
      try {
        preparationTasks = await supabaseDb.getPreparationTasks()
      } catch (error) {
        console.warn('Could not load preparation tasks:', error)
      }
      
      console.log('üéâ Startup data loading completed:', {
        categories: categories.length,
        products: products.length,
        items: items.length,
        users: users.length,
        orders: orders.length,
        preparationTasks: preparationTasks.length
      })
      
      const syncTime = new Date().toISOString()
      set({
        categories,
        products,
        items,
        orders,
        preparationTasks,
        users,
        lastSyncTime: syncTime,
        lastFullSyncTime: syncTime, // ÂàùÂõû„Éá„Éº„ÇøË™≠„ÅøËæº„ÅøÊôÇ„Å´ÂÖ®ÂêåÊúüÊôÇÂàª„ÇÇË®≠ÂÆö
        isDataInitialized: true // ÂàùÊúüÂåñÂÆå‰∫Ü„Éï„É©„Ç∞„ÇíË®≠ÂÆö
      })
    } catch (error) {
      console.error('‚ùå Error loading startup data:', error)
      // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Å®„Åó„Å¶Âü∫Êú¨ÁöÑ„Å™loadData„ÇíÂÆüË°å
      console.log('üîÑ Falling back to basic loadData...')
      await get().loadData()
    }
  },

  loadItemsForCategory: async (categoryId: string) => {
    console.log(`üì¶ Loading items for category: ${categoryId}`)
    try {
      const items = await supabaseDb.getProductItemsByCategoryId(categoryId)
      console.log(`‚úÖ Loaded ${items.length} items for category ${categoryId}`)
      set({ items })
    } catch (error) {
      console.error('Error loading items for category:', error)
    }
  },

  loadItemsForProduct: async (productId: string) => {
    console.log(`üì¶ Loading items for product: ${productId}`)
    try {
      const items = await supabaseDb.getProductItemsByProductId(productId)
      console.log(`‚úÖ Loaded ${items.length} items for product ${productId}`)
      set({ items })
    } catch (error) {
      console.error('Error loading items for product:', error)
    }
  },
  
  setViewMode: (mode) => set({ viewMode: mode }),
  
  setSelectedCategory: (categoryId) => set({ 
    selectedCategory: categoryId,
    selectedProduct: null 
  }),
  
  setSelectedProduct: (productId) => set({ 
    selectedProduct: productId 
  }),
  
  updateItemStatus: async (itemId, status) => {
    console.log(`üöÄ Optimistic updateItemStatus called: ${itemId} -> ${status}`)
    
    const { items } = get()
    const targetItem = items.find(i => i.id === itemId)
    
    if (!targetItem) {
      console.error('‚ùå Item not found in store:', itemId)
      throw new Error(`Item ${itemId} not found`)
    }
    
    const originalStatus = targetItem.status
    console.log(`üîÑ Optimistic update: ${originalStatus} -> ${status}`)
    
    // 1. Ê•ΩË¶≥ÁöÑÊõ¥Êñ∞ÔºöÂç≥Â∫ß„Å´„Çπ„Éà„Ç¢„ÇíÊõ¥Êñ∞Ôºà„É¶„Éº„Ç∂„Éº„Å´„ÅØÁû¨ÊôÇÂèçÊò†Ôºâ
    const updatedItem = { ...targetItem, status }
    const updatedItems = items.map(i => i.id === itemId ? updatedItem : i)
    set({ items: updatedItems })
    get().clearItemsCache()
    console.log('‚ö° Optimistic update applied to store')
    
    try {
      // 2. „Éá„Éº„Çø„Éô„Éº„Çπ‰øùÂ≠òÔºàÈùûÂêåÊúüÔºâ
      await supabaseDb.saveProductItem(updatedItem)
      console.log('‚úÖ Item saved to database successfully')
      
      // 3. ÊàêÂäüÊôÇ„ÅØËøΩÂä†Âá¶ÁêÜ„Å™„ÅóÔºàÊó¢„Å´„Çπ„Éà„Ç¢Êõ¥Êñ∞Ê∏à„ÅøÔºâ
      
    } catch (error) {
      console.error('‚ùå Database save failed, rolling back...', error)
      
      // 4. „Ç®„É©„ÉºÊôÇÔºö„É≠„Éº„É´„Éê„ÉÉ„ÇØÔºàÂÖÉ„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„Å´Êàª„ÅôÔºâ
      const rolledBackItem = { ...targetItem, status: originalStatus }
      const rolledBackItems = items.map(i => i.id === itemId ? rolledBackItem : i)
      set({ items: rolledBackItems })
      get().clearItemsCache()
      console.log('üîô Rolled back to original status:', originalStatus)
      
      // „Ç®„É©„Éº„ÇíÂÜçÊäï„Åí„Åó„Å¶Âëº„Å≥Âá∫„ÅóÂÖÉ„Å´ÈÄöÁü•
      throw error
    }
  },
  
  createOrder: async (orderData) => {
    console.log('üöÄ createOrder called with data:', orderData)
    try {
      const newOrder: Order = {
        ...orderData,
        id: `ORD-${Date.now()}`,
      }
      console.log('üì¶ Created new order object:', newOrder)
      
      await supabaseDb.saveOrder(newOrder)
      console.log('‚úÖ Order saved to database successfully')
      
      const { orders } = get()
      const updatedOrders = [...orders, newOrder]
      set({ orders: updatedOrders })
      console.log('üìä Store updated, total orders:', updatedOrders.length)
    } catch (error) {
      console.error('‚ùå Error creating order:', error)
      throw error
    }
  },
  
  updateOrderStatus: async (orderId, status) => {
    try {
      const order = await supabaseDb.getOrderById(orderId)
      if (order) {
        const updatedOrder = { ...order, status }
        await supabaseDb.saveOrder(updatedOrder)
        
        const { orders } = get()
        const updatedOrders = orders.map(o => 
          o.id === orderId ? updatedOrder : o
        )
        set({ orders: updatedOrders })
      }
    } catch (error) {
      console.error('Error updating order status:', error)
    }
  },
  
  createPreparationTask: async (taskData) => {
    try {
      const newTask: PreparationTask = {
        ...taskData,
        id: `TASK-${Date.now()}`,
      }
      await supabaseDb.savePreparationTask(newTask)
      
      const { preparationTasks } = get()
      set({ preparationTasks: [...preparationTasks, newTask] })
    } catch (error) {
      console.error('Error creating preparation task:', error)
    }
  },
  
  updatePreparationTaskStatus: async (taskId, status) => {
    try {
      const completedDate = status === 'completed' ? new Date().toISOString() : undefined
      await supabaseDb.updatePreparationTaskStatus(taskId, status, completedDate)
      
      const { preparationTasks } = get()
      const updatedTasks = preparationTasks.map(task => 
        task.id === taskId 
          ? { ...task, status, completedDate } 
          : task
      )
      set({ preparationTasks: updatedTasks })
    } catch (error) {
      console.error('Error updating preparation task status:', error)
    }
  },
  
  addProduct: async (productData) => {
    try {
      const newProduct: Product = {
        ...productData,
        id: `PRD-${Date.now()}`,
      }
      await supabaseDb.saveProduct(newProduct)
      
      const { products } = get()
      set({ products: [...products, newProduct] })
    } catch (error) {
      console.error('Error adding product:', error)
    }
  },
  
  addProductItem: async (itemData) => {
    try {
      const newItem: ProductItem = {
        ...itemData,
        id: `ITM-${Date.now()}`,
      }
      await supabaseDb.saveProductItem(newItem)
      
      const { items } = get()
      set({ items: [...items, newItem] })
      // „Ç¢„Ç§„ÉÜ„É†„ÅåËøΩÂä†„Åï„Çå„Åü„ÅÆ„Åß„Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÇØ„É™„Ç¢
      get().clearItemsCache()
    } catch (error) {
      console.error('Error adding product item:', error)
    }
  },
  
  addCategory: async (categoryData) => {
    try {
      const newCategory: ProductCategory = {
        ...categoryData,
        id: `CAT-${Date.now()}`,
      }
      await supabaseDb.saveCategory(newCategory)
      
      const { categories } = get()
      set({ categories: [...categories, newCategory] })
    } catch (error) {
      console.error('Error adding category:', error)
    }
  },
  
  getInventoryStats: () => {
    // Return basic stats from current store state
    const { categories, products, items } = get()
    return {
      totalCategories: categories.length,
      totalProducts: products.length,
      totalItems: items.length,
      availableItems: items.filter(item => item.status === 'available').length,
      rentedItems: items.filter(item => item.status === 'rented').length,
      maintenanceItems: items.filter(item => item.status === 'maintenance').length
    }
  },

  // Inventory calculation methods
  getInventorySummary: () => {
    const { products, items, orders } = get()
    return calculateInventorySummary(products, items, orders)
  },

  getProductAvailableStock: (productId: string) => {
    const { items, orders } = get()
    return getAvailableStock(productId, items, orders)
  },

  getReservations: () => {
    const { orders } = get()
    return calculateReservations(orders)
  },

  // Realtime functions
  enableRealtime: () => {
    const state = get()
    if (state.isRealtimeEnabled) return

    console.log('üîÑ Enabling category-wise realtime synchronization...')

    // Êó¢Â≠ò„ÅÆÊé•Á∂ö„Çí„ÇØ„É™„Ç¢
    realtimeSubscriptions.forEach(sub => {
      if (sub && sub.unsubscribe) {
        sub.unsubscribe()
      }
    })
    realtimeSubscriptions = []

    // „Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆÂêÑ„ÉÜ„Éº„Éñ„É´„Çí„É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñÔºàÂ≠òÂú®„Åô„Çã„ÉÜ„Éº„Éñ„É´„ÅÆ„ÅøÔºâ
    const tables = ['categories', 'products', 'product_items', 'orders', 'order_items', 'users']
    
    // Âçò‰∏Ä„ÅÆ„ÉÅ„É£„Éç„É´„ÅßÂÖ®„ÉÜ„Éº„Éñ„É´„ÇíÁõ£Ë¶ñÔºàÊé•Á∂öÂäπÁéáÂåñÔºâ
    const channel = supabase.channel('db-changes')
    
    tables.forEach(table => {
      channel.on('postgres_changes', 
        { event: '*', schema: 'public', table: table },
        async (payload) => {
          console.log(`üîÑ Realtime update from ${table}:`, payload)
            
            const currentState = get()
            if (!currentState.isRealtimeEnabled) return
            
            try {
              // „ÉÜ„Éº„Éñ„É´„Å´Âøú„Åò„Å¶ÂäπÁéáÁöÑ„Å™Êõ¥Êñ∞„ÇíÂÆüË°å
              if (table === 'product_items') {
                // ÂïÜÂìÅ„Ç¢„Ç§„ÉÜ„É†„ÅÆÂ§âÊõ¥ÔºöËªΩÈáè„Å™ÂÄãÂà•Êõ¥Êñ∞
                console.log('üì¶ Product item changed, applying lightweight update...')
                
                
                const { eventType, new: newData, old: oldData } = payload
                console.log(`üîÑ ${eventType} event:`, { newData, oldData })
                
                if (eventType === 'UPDATE' && newData) {
                  // ÂÄãÂà•„Ç¢„Ç§„ÉÜ„É†„ÅÆÊõ¥Êñ∞Ôºà‰ªñ„ÅÆ„É¶„Éº„Ç∂„Éº„Åã„Çâ„ÅÆÂ§âÊõ¥Ôºâ
                  const { items } = currentState
                  const updatedItems = items.map(item => 
                    item.id === newData.id ? newData : item
                  )
                  set({ items: updatedItems })
                  currentState.clearItemsCache()
                  console.log('‚ö° Individual item updated in store:', newData.id)
                  
                } else if (eventType === 'INSERT' && newData) {
                  // Êñ∞„Åó„ÅÑ„Ç¢„Ç§„ÉÜ„É†„ÅÆËøΩÂä†
                  const { items } = currentState
                  const updatedItems = [...items, newData]
                  set({ items: updatedItems })
                  currentState.clearItemsCache()
                  console.log('‚ûï New item added to store:', newData.id)
                  
                } else if (eventType === 'DELETE' && oldData) {
                  // „Ç¢„Ç§„ÉÜ„É†„ÅÆÂâäÈô§
                  const { items } = currentState
                  const updatedItems = items.filter(item => item.id !== oldData.id)
                  set({ items: updatedItems })
                  currentState.clearItemsCache()
                  console.log('üóëÔ∏è Item removed from store:', oldData.id)
                }
                
              } else if (table === 'orders' || table === 'order_items') {
                // „Ç™„Éº„ÉÄ„ÉºÈñ¢ÈÄ£ÔºöËªΩÈáè„Å™Êõ¥Êñ∞„ÅÆ„ÅøÔºàÈ†ªÁπÅ„Å´Â§âÊõ¥„Åï„Çå„Çã„Åü„ÇÅÔºâ
                console.log(`üìä ${table} changed, refreshing orders...`)
                try {
                  const orders = await supabaseDb.getOrders()
                  set({ orders })
                } catch (error) {
                  console.error('Error refreshing orders:', error)
                }
              } else {
                // „Åù„ÅÆ‰ªñ„ÅÆ„ÉÜ„Éº„Éñ„É´ÔºöÂü∫Êú¨ÁöÑ„Å™loadData„ÅÆ„Åø
                console.log(`üìä ${table} changed, reloading basic data...`)
                await currentState.loadData()
              }
              
              set({ lastSyncTime: new Date().toISOString() })
            } catch (error) {
              console.error('‚ùå Error during realtime sync:', error)
            }
          }
        )
    })
    
    // „ÉÅ„É£„Éç„É´„ÇíË≥ºË™≠
    channel.subscribe((status) => {
      console.log(`üì° Realtime channel status:`, status)
      if (status === 'SUBSCRIBED') {
        console.log('‚úÖ Successfully connected to realtime updates!')
      }
    })
    
    realtimeSubscriptions.push(channel)

    set({ 
      isRealtimeEnabled: true,
      lastSyncTime: new Date().toISOString()
    })
    
    console.log('‚úÖ Category-wise realtime synchronization enabled!')
  },

  disableRealtime: () => {
    console.log('üõë Disabling realtime synchronization...')
    
    // ÂÖ®„Å¶„ÅÆÊé•Á∂ö„ÇíÂàáÊñ≠
    realtimeSubscriptions.forEach(sub => {
      if (sub && sub.unsubscribe) {
        sub.unsubscribe()
      }
    })
    realtimeSubscriptions = []

    set({ 
      isRealtimeEnabled: false,
      lastSyncTime: null
    })
    
    console.log('‚úÖ Realtime synchronization disabled!')
  },

  forceSync: async () => {
    console.log('üîÑ Force syncing data with category-wise approach...')
    const { loadAllDataOnStartup, clearItemsCache } = get()
    clearItemsCache() // Âº∑Âà∂ÂêåÊúüÊôÇ„ÅØ„Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÇØ„É™„Ç¢
    await loadAllDataOnStartup()
    set({ lastSyncTime: new Date().toISOString() })
    console.log('‚úÖ Force sync completed!')
  },

  checkAndPerformDailySync: async () => {
    const { lastFullSyncTime, loadAllDataOnStartup, clearItemsCache } = get()
    const now = new Date()
    
    // ÊúÄÂæå„ÅÆÂÖ®ÂêåÊúü„Åã„Çâ24ÊôÇÈñìÁµåÈÅé„Åó„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
    if (!lastFullSyncTime) {
      console.log('üìÖ No previous full sync time found, performing initial daily sync...')
    } else {
      const lastSync = new Date(lastFullSyncTime)
      const hoursSinceLastSync = (now.getTime() - lastSync.getTime()) / (1000 * 60 * 60)
      
      if (hoursSinceLastSync < 24) {
        console.log(`üìÖ Last full sync was ${hoursSinceLastSync.toFixed(1)} hours ago, skipping daily sync`)
        return
      }
      
      console.log(`üìÖ Last full sync was ${hoursSinceLastSync.toFixed(1)} hours ago, performing daily sync...`)
    }
    
    try {
      // ÂÖ®„Éá„Éº„Çø„ÇíÂÜçË™≠„ÅøËæº„Åø
      clearItemsCache()
      await loadAllDataOnStartup()
      
      // ÂÖ®ÂêåÊúüÊôÇÂàª„ÇíÊõ¥Êñ∞
      const syncTime = now.toISOString()
      set({ 
        lastFullSyncTime: syncTime,
        lastSyncTime: syncTime
      })
      
      console.log('‚úÖ Daily full sync completed successfully!')
    } catch (error) {
      console.error('‚ùå Error during daily sync:', error)
    }
  },

  clearItemsCache: () => {
    set(state => ({
      itemsCache: {
        categories: {},
        products: {}
      }
    }))
  },

  resetUIState: () => {
    set({
      selectedCategory: null,
      selectedProduct: null,
      viewMode: 'category'
    })
  },
}))

// „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Ëµ∑ÂãïÊôÇ„Å´„É™„Ç¢„É´„Çø„Ç§„É†ÂêåÊúü„ÇíËá™ÂãïÈñãÂßãÔºà‰∏ÄÊôÇÁöÑ„Å´ÁÑ°ÂäπÂåñÔºâ
if (typeof window !== 'undefined') {
  // „É™„Ç¢„É´„Çø„Ç§„É†ÂêåÊúü„Çí‰∏ÄÊôÇÁöÑ„Å´ÁÑ°ÂäπÂåñ
  console.log('‚ÑπÔ∏è Realtime synchronization is temporarily disabled')
  // window.addEventListener('load', () => {
  //   setTimeout(() => {
  //     const store = useInventoryStore.getState()
  //     console.log('üöÄ Auto-enabling realtime synchronization...')
  //     store.enableRealtime()
  //   }, 1000)
  // })
  
  // „Éö„Éº„Ç∏„ÇíÈõ¢„Çå„ÇãÊôÇ„Å´„É™„Ç¢„É´„Çø„Ç§„É†ÂêåÊúü„ÇíÂÅúÊ≠¢
  window.addEventListener('beforeunload', () => {
    const store = useInventoryStore.getState()
    if (store.isRealtimeEnabled) {
      console.log('üõë Disabling realtime due to page unload...')
      store.disableRealtime()
    }
  })
  
  // „Éö„Éº„Ç∏„Åå„Éï„Ç©„Éº„Ç´„Çπ„Åï„Çå„ÅüÊôÇ„Å´Â∑ÆÂàÜÂêåÊúüÔºàÊúÄËøëÊõ¥Êñ∞„Åï„Çå„Åü„Ç¢„Ç§„ÉÜ„É†„ÅÆ„ÅøÔºâ
  window.addEventListener('focus', async () => {
    const store = useInventoryStore.getState()
    if (store.isRealtimeEnabled && store.lastSyncTime) {
      console.log('üîÑ Page focused, performing differential sync...')
      try {
        // ÊúÄÂæå„ÅÆÂêåÊúüÊôÇÂàª‰ª•Èôç„Å´Êõ¥Êñ∞„Åï„Çå„Åü„Ç¢„Ç§„ÉÜ„É†„ÅÆ„ÅøÂèñÂæó
        const recentItems = await supabaseDb.getRecentlyUpdatedProductItems(store.lastSyncTime)
        
        if (recentItems.length > 0) {
          console.log(`üì¶ Found ${recentItems.length} updated items since last sync`)
          
          // Êó¢Â≠ò„ÅÆ„Ç¢„Ç§„ÉÜ„É†„É™„Çπ„Éà„ÇíÊõ¥Êñ∞
          const currentItems = store.items
          const updatedItems = [...currentItems]
          
          recentItems.forEach(recentItem => {
            const existingIndex = updatedItems.findIndex(item => item.id === recentItem.id)
            if (existingIndex >= 0) {
              // Êó¢Â≠ò„Ç¢„Ç§„ÉÜ„É†„ÇíÊõ¥Êñ∞
              updatedItems[existingIndex] = recentItem
            } else {
              // Êñ∞„Åó„ÅÑ„Ç¢„Ç§„ÉÜ„É†„ÇíËøΩÂä†
              updatedItems.push(recentItem)
            }
          })
          
          store.clearItemsCache()
          useInventoryStore.setState({ 
            items: updatedItems,
            lastSyncTime: new Date().toISOString()
          })
          console.log('‚úÖ Differential sync completed')
        } else {
          console.log('üì¶ No updates found since last sync')
        }
      } catch (error) {
        console.error('‚ùå Error during differential sync:', error)
      }
    } else if (store.isRealtimeEnabled && !store.lastSyncTime) {
      console.log('‚ÑπÔ∏è No last sync time available, skipping differential sync')
    }
  })
  
  // ÂÆöÊúüÁöÑ„Å™Êó•Ê¨°ÂÖ®ÂêåÊúü„ÉÅ„Çß„ÉÉ„ÇØÔºà6ÊôÇÈñì„Åî„Å®Ôºâ
  const checkDailySyncInterval = setInterval(async () => {
    try {
      const store = useInventoryStore.getState()
      if (store.isDataInitialized) {
        await store.checkAndPerformDailySync()
      }
    } catch (error) {
      console.error('‚ùå Error during periodic daily sync check:', error)
    }
  }, 6 * 60 * 60 * 1000) // 6ÊôÇÈñì = 6 * 60 * 60 * 1000ms
  
  // „Éö„Éº„Ç∏„ÇíÈõ¢„Çå„ÇãÊôÇ„Å´ÂÆöÊúü„ÉÅ„Çß„ÉÉ„ÇØ„ÇíÂÅúÊ≠¢
  window.addEventListener('beforeunload', () => {
    clearInterval(checkDailySyncInterval)
  })
}